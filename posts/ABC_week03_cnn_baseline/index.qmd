---
title: "[2025 ABC 프로젝트 멘토링 8기] 3주차 - CNN으로 시계열 이상 탐지"
description: "베이스라인 1D CNN 오토인코더를 이용하여 시계열 데이터의 이상 탐지 베이스라인 모델을 구현하였다."
date: 2025-06-08
author: "Beomdo Park"
categories: ["ABC프로젝트멘토링", "유클리드소프트", "고용노동부", "대한상공회의소", "미래내일일경험사업"]
page-layout: full
freeze: false
---

> 안녕하세요, ABC 프로젝트 멘토링 8기 세 번째 기술노트입니다. 이번 주는 시계열 데이터의 '패턴'을 학습할 수 있는 딥러닝, 그중에서도 CNN을 활용한 이상 탐지의 첫걸음을 떼어 보겠습니다.

::: {.callout-tip title="이전 포스트"}
[Week2 포스트](https://beomdo-park.github.io/posts/ABC_week02_time_series_anomaly/)에서 머신러닝 기반 이상 탐지 기법을 다뤘습니다. 이번 포스트는 이를 기반으로 딥러닝 접근법을 소개합니다.
:::

```{python}
#| label: matplotlib-font-setup
#| echo: false
#| include: false
#| eval: true
import os, sys
# matplotlib 한글 폰트 설정 스크립트 경로 (프로젝트 루트 기준)
# 현재 파일 위치: posts/ABC_week03_cnn_baseline/index.qmd
# 스크립트 위치: scripts/matplotlib_font_setup.py
font_setup_script_path = "../../scripts/matplotlib_font_setup.py" 
try:
    if os.path.exists(font_setup_script_path):
        exec(open(font_setup_script_path, encoding='utf-8').read())
    else:
        # 스크립트 파일이 없을 경우 기본 설정
        import platform
        import matplotlib.pyplot as plt
        if platform.system() == 'Windows':
            plt.rc('font', family='NanumGothic') # Windows에 NanumGothic이 설치되어 있다고 가정
        elif platform.system() == 'Darwin': # MacOS
            plt.rc('font', family='AppleGothic')
        else: # Linux 등 기타
            try:
                plt.rc('font', family='NanumGothic')
            except:
                print("NanumGothic not found. Using system default font.")
        plt.rcParams['axes.unicode_minus'] = False # 마이너스 폰트 깨짐 방지
except Exception as e:
    print(f"Font setup failed: {e}")
    import matplotlib.pyplot as plt
    plt.rcParams['axes.unicode_minus'] = False # 마이너스 폰트 깨짐 방지
```

## 1. 시계열 데이터를 CNN에 입력하는 방법: 윈도잉(Windowing)

시계열 데이터를 CNN 모델에 입력하려면 연속된 데이터를 일정한 길이의 조각(window)으로 나누는 '슬라이딩 윈도우' 기법이 필요합니다. 이 방법은 데이터의 시간적 패턴을 학습하는 데 유용합니다.

### 슬라이딩 윈도우 구현

아래는 numpy를 사용해 슬라이딩 윈도우를 구현하는 간단한 Python 함수입니다:

```{python}
#| label: sliding-window-implementation
#| echo: true
#| include: true
#| eval: true
import numpy as np

def sliding_window(data, window_size, step_size=1):
    """시계열 데이터를 슬라이딩 윈도우로 변환"""
    n_windows = (len(data) - window_size) // step_size + 1
    return np.array([data[i:i+window_size] for i in range(0, n_windows * step_size, step_size)])

# 예제 데이터
data = np.sin(np.linspace(0, 20, 100))
windowed_data = sliding_window(data, window_size=10)
print("윈도우 형태:", windowed_data.shape)
```

## 2. 기본 이상 탐지 모델: CNN 오토인코더 (Autoencoder)

### 오토인코더란?
오토인코더는 데이터를 압축(인코더)했다가 다시 복원(디코더)하도록 학습하는 딥러닝 모델입니다. 정상 데이터는 잘 복원되지만, 이상 데이터는 복원이 잘 되지 않아 재구성 오차가 커지는 특징을 활용합니다.

### 모델 구조

- **인코더 (Encoder):** Conv1D와 MaxPooling1D 층을 사용해 입력 데이터의 특징을 추출하고 압축합니다.
- **디코더 (Decoder):** Conv1DTranspose 또는 UpSampling1D 층을 사용해 데이터를 복원합니다.

### TensorFlow/Keras 구현

아래는 간단한 1D CNN 오토인코더 모델 구현입니다:

```{python}
#| label: cnn-autoencoder-definition
#| echo: true
#| include: true
#| eval: true
import tensorflow as tf
from tensorflow.keras import layers, models

# CNN Autoencoder 모델 정의
def create_cnn_autoencoder(input_shape):
    inputs = layers.Input(shape=input_shape)

    # 인코더
    x = layers.Conv1D(32, kernel_size=3, activation='relu', padding='same')(inputs)
    x = layers.MaxPooling1D(pool_size=2, padding='same')(x)
    x = layers.Conv1D(16, kernel_size=3, activation='relu', padding='same')(x)
    encoded = layers.MaxPooling1D(pool_size=2, padding='same')(x)

    # 디코더
    x = layers.Conv1DTranspose(16, kernel_size=3, activation='relu', padding='same')(encoded)
    x = layers.UpSampling1D(size=2)(x)
    x = layers.Conv1DTranspose(32, kernel_size=3, activation='relu', padding='same')(x)
    x = layers.UpSampling1D(size=2)(x)
    decoded = layers.Conv1D(1, kernel_size=3, activation='sigmoid', padding='same')(x)

    return models.Model(inputs, decoded)

# 모델 생성 및 컴파일은 data-generation 셀 이후로 이동합니다.
# input_shape도 window_size를 사용하도록 수정됩니다.
```

## 3. 모델 학습 및 이상치 탐지

### 데이터 생성

Week2에서 사용한 샘플 데이터를 기반으로 정상/비정상 데이터를 생성합니다:

```{python}
#| label: data-generation
#| echo: true
#| include: true
#| eval: true
# 데이터 생성
np.random.seed(42)
data = np.sin(0.2 * np.arange(0, 100)) + np.random.normal(0, 0.1, 100)
outliers = [20, 50, 80]
data[outliers] += [3, -3, 2]

# 슬라이딩 윈도우 적용
window_size = 10
windows = sliding_window(data, window_size)
windows = windows[..., np.newaxis]  # CNN 입력 형태로 변환
```

```{python}
#| label: cnn-autoencoder-creation
#| echo: true
#| include: true
#| eval: true
# 모델 생성
# input_shape은 (window_size, 1) 이어야 합니다. window_size는 data-generation 셀에서 정의됩니다.
model_input_shape = (window_size, 1) # data-generation 셀에서 정의된 window_size 사용
model = create_cnn_autoencoder(model_input_shape) # cnn-autoencoder-definition 셀에서 정의된 함수 사용
model.compile(optimizer='adam', loss='mse')
model.summary()
```

### 모델 학습

정상 데이터만 사용해 모델을 학습합니다:

```{python}
#| label: model-training
#| echo: true
#| include: true
#| eval: true
# 정상 데이터로 학습
# 'outliers'는 원본 'data' 배열의 인덱스입니다.
# 'windows' 배열에서 이상치가 포함된 윈도우를 식별하여 제외해야 합니다.
contaminated_window_indices = set()
# 'outliers', 'window_size', 'windows' 변수는 이전 셀들에서 정의되어 있어야 합니다.
for outlier_data_idx in outliers: 
    # 이 이상치 데이터 포인트를 포함하는 모든 윈도우를 찾습니다.
    # 윈도우 i는 data[i]에서 data[i + window_size - 1]까지 커버합니다 (step_size=1 가정).
    # 따라서, 윈도우 i가 outlier_data_idx를 포함하려면:
    # i <= outlier_data_idx < i + window_size
    # 즉, (outlier_data_idx - window_size + 1) <= i <= outlier_data_idx

    start_contaminated_win_idx = max(0, outlier_data_idx - window_size + 1)
    end_contaminated_win_idx = outlier_data_idx 
    
    for win_idx in range(start_contaminated_win_idx, end_contaminated_win_idx + 1):
        if win_idx < len(windows): # 윈도우 인덱스가 유효한 범위 내에 있는지 확인
            contaminated_window_indices.add(win_idx)

normal_windows_mask = np.ones(len(windows), dtype=bool)
if contaminated_window_indices: # set이 비어있지 않은 경우에만 인덱싱
    normal_windows_mask[list(contaminated_window_indices)] = False
normal_windows = windows[normal_windows_mask]

if len(normal_windows) == 0:
    print("경고: 학습에 사용할 정상 윈도우가 없습니다. Outlier 정의, window_size 또는 데이터 길이를 확인하세요.")
else:
    model.fit(normal_windows, normal_windows, epochs=20, batch_size=16, verbose=1)
```

### 재구성 오차 계산 및 이상치 탐지

학습된 모델로 데이터를 복원하고, 재구성 오차를 계산합니다:

```{python}
#| label: reconstruction-error
#| echo: true
#| include: true
#| eval: true
# 재구성 오차 계산
reconstructed = model.predict(windows)
mae = np.mean(np.abs(windows - reconstructed), axis=(1, 2))

# 이상치 탐지
threshold = 0.5  # 임계값 설정
anomalies = np.where(mae > threshold)[0]

print("이상치 인덱스:", anomalies)
```

### 결과 시각화

```{python}
#| label: visualization
#| fig-cap: "CNN 오토인코더 기반 이상 탐지 결과"
#| echo: true
#| include: true
#| eval: true
import matplotlib.pyplot as plt

plt.figure(figsize=(10, 6))
plt.plot(data, label='원본 데이터')
plt.scatter(outliers, data[outliers], color='red', label='실제 이상치')
plt.scatter(anomalies, data[anomalies], color='orange', label='탐지된 이상치')
plt.legend()
plt.title('CNN 오토인코더 기반 이상 탐지')
plt.show()
```

## 결론 및 다음 단계

이번 주에는 간단한 CNN 오토인코더를 설계하고, 이를 활용해 시계열 데이터의 이상 탐지를 수행했습니다. 이 모델은 시계열 이상 탐지의 강력한 베이스라인이 될 수 있습니다.

다음 포스트에서는 실제 산업 데이터를 사용해 모델을 학습시키고, 성능을 개선하기 위한 다양한 방법을 탐구해 보겠습니다.
